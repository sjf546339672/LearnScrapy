一、爬取非中文数据python2
二、爬取中文数据python3
三、urlopen只能处理http
四、VPS 秒换ip
五、import ssl   ssl._create_unverified_context()  # 忽略安全 https
六、selenium  验证码 模拟登陆不需要加密
七、requests urllib2 只能处理非加密的post，速度快，局限性大

八、mysql的引擎:
（1）：MyISAM存储引擎
不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表
    支持3种不同的存储格式，分别是：静态表；动态表；压缩表
    静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；
        缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，
        如果不注意会把数据本身带的空格也会忽略。
    动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，
        需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能
    压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支

（2）InnoDB存储引擎*
该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，
并且会占用更多的磁盘空间以保留数据和索引。InnoDB存储引擎的特点：支持自动增长列，支持外键约束

(3)：MEMORY存储引擎
Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，
因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。
MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围

Hash索引优点：
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，
最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。
Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；

Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到
最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，
所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。

（4）MERGE存储引擎
Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，
更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。

九、redis的数据类型:
    Redis支持五种数据类型string（字符串）,list（列表）,set（集合）及zset(sorted set：有序集合), hash（哈希）

十、redis的四大特性:
事物的四大特性：（ACID）
原子性（Atomicity）
    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，
    如果操作失败则不能对数据库有任何影响。
一致性（Consistency）
    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
    示例：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，
    事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
隔离性（Isolation）
    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，
    多个并发事务之间要相互隔离。
    即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，
    这样每个事务都感觉不到有其他事务在并发地执行。
持久性（Durability）
    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

十一、懒加载:

十二、装饰器:

十三、with上下文管理器的两个方法:
是不是发现使用with语句相对try/finally来说简洁了很多，而且也不需要每一个用户都去写f.close()来关闭文件了，
这是因为with语句在背后做了大量的工作。with语句的expression是上下文管理器，这个我们下文会说。with语句中的[as variable]是可选的，
如果指定了as variable说明符，则variable是上下文管理器expression调用__enter__()函数返回的对象。所以，f并不一定就是expression，
而是expression.__enter__()的返回值，至于expression.__enter__()返回什么就由这个函数来决定了。with-block是执行语句，
with-block执行完毕时，with语句会自动进行资源清理，对应上面例子就是with语句会自动关闭文件。
下面我们来具体说下with语句在背后默默无闻地到底做了哪些事情。刚才我们说了expression是一个上下文管理器，
其实现了__enter__和__exit__两个函数。当我们调用一个with语句时，执行过程如下：
    1.首先生成一个上下文管理器expression，在上面例子中with语句首先以“test.txt”作为参数生成一个上下文管理器open("test.txt")。
    2.然后执行expression.__enter__()。如果指定了[as variable]说明符，将__enter__()的返回值赋给variable。
    上例中open("test.txt").__enter__()返回的是一个文件对象给f。
    3.执行with-block语句块。上例中执行读取文件。
    4.执行expression.__exit__(),在__exit__()函数中可以进行资源清理工作。上面例子中就是执行文件的关闭操作。

十四、迭代器工作原理:
迭代器的原理及源码解析
A：迭代器原理
    迭代器原理：迭代器是对集合进行遍历，而每一个集合内部的存储结构都是不同的，所以每一个集合存和取都是不一样，那么就需要在每一
    个类中定义hasNext()和next()方法，这样做是可以的，但是会让整个集合体系过于臃肿，迭代器是将这样的方法向上抽取出接口，然后在
    每个类的内部，定义自己迭代方式。这样做的好处有二：第一规定了整个集合体系的遍历方式都是hasNext()和next()方法；
    第二代码有底层内部实现。
B：迭代器源码解析
    1.在eclipse中ctrl + shift + t找到ArrayList类
    2.ctrl+o查找iterator()方法
    3.查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口
    4.查找Itr这个内部类,发现重写了Iterator中的所有抽象方法

十五、查看列表的内存地址：
id(list)


十六、列表如何乱序
random.shuffle(list)


十七、Python字符串如何动态加载模块
不确定  import  __import__(string)


十八、__init__.py文件的作用
如果目录中存在该文件就会被识别为模块包


十九、基础类object的方法和属性有哪些（Object的的方法和属性）
__str__()  __repr__()  __reduce__()  __init__() __dir__() __eq__() __format__()


二十、代理ip如何使用的
px = request.ProxyHandler({"http": "1.1.1.1"})
opener = request.build_opener(px)  # build_opener()来构建一个opener对象
req = request.Request("网址")
resp = opener.open(req)  # 调用构建好的opener对象里面的open方法来发生请求。实际上urlopen也是类似这样使用内部定义好的opener.open()，这里就相当于我们自己重写
request.install_opener(opener)  # 自定义的opener设置成全局的

